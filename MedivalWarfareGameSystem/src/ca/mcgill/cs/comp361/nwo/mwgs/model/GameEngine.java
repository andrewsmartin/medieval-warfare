package ca.mcgill.cs.comp361.nwo.mwgs.model;

import java.util.ArrayList;
import java.util.List;



/**
 * GameEngine class definition.
 * Generated by the TouchCORE code generator.
 */
public class GameEngine {
    
    private Game gameState;
    
    public void buildRoad(Unit u) {
        Tile tile;
        tile = u.getTile();
        if (u.getUnitType() == UnitType.PEASANT && tile.getStructure() != StructureType.ROAD) {
            u.setCurrentAction(ActionType.BUILDINGROAD);
            u.setImmobileUntilRound(gameState.getRoundCount() + 1);
            tile.setStructure(StructureType.ROAD);
        }
    }

    public void takeoverTile(Tile dest) {
        Unit unit = dest.getUnit();
        Village destVillage = dest.getVillage();
        Village unitsVillage = unit.getVillage();
        
        if (destVillage != null) {
            unitsVillage.transactGold(destVillage.getGold());
            unitsVillage.transactWood(destVillage.getWood());
            dest.setVillage(null);
        }
        dest.getRegion().removeTile(dest);
        unitsVillage.getRegion().addTile(dest);
        splitRegions(unit);
        checkWinConditions();
    }

    private void checkWinConditions() {
        List<Player> players = new ArrayList<Player>(gameState.getPlayers());
        for (Player p : players) {
            if (p.getVillages().size() <= 0) {
                players.remove(p);
            }
        }
        if (players.size() <= 1) {
            gameState.setHasWon(true);
            players.get(0).incrementWinCount();
            for (Player p : gameState.getPlayers()) {
                if (!p.equals(players.get(0))) p.incrementLossCount();
            }
        }
    }

    public void newGame(List<Player> players, String mapChosen) {
        /* TODO Correct SetUpMap */
        Map map = Map.setUpMap(players, mapChosen);
        Game game= new Game(players, map);
        Player.setUpPlayers(players);
        setGameState(game);
    }

    public void beginTurn(Game g, Player p) {
        Map map = g.getMap();
        phaseBuild(p);
        phaseTombstone(p, map);
        phaseIncome(p);
        phasePayment(p);
    }

    public void upgradeUnit(Unit u, UnitType newLevel) {
        Village v = u.getVillage();
        int cost = Unit.unitLevel(newLevel) - Unit.unitLevel(u.getUnitType());
        if (v.getGold() >= cost) {
            u.setUnitType(newLevel);
            v.transactGold(-1 * cost);
        }
    }

    public void upgradeVillage(Village v, VillageType newLevel) {
        int cost = Village.villageCost(newLevel) - Village.villageCost(v.getVillageType());
        if (v.getWood() >= cost) {
            v.setVillageType(newLevel);
            v.transactWood(-1 * cost);
        }
    }

    public void buildTower(Tile t) {
        /* TODO: No message view defined */
    }

    public Game getGameState() {
        return gameState;
    }

    public void setGameState(Game gameState) {
        this.gameState = gameState;
    }

    private MoveType getMoveType(Unit u, Tile dest) {
        /* TODO Implement */
        Tile origin = u.getTile();;
        List<Tile> adjacent = origin.getNeighbours();
        // Please refer to the attached pseudocode;
        // This sequence diagram does not check every case we intend to check;
        if (adjacent.contains(dest)) {
            TerrainType landOnDest = dest.getTerrainType();
            StructureType structureOnDest = dest.getStructure();
            Unit unitOnDest = dest.getUnit();
            Village villageOnDest = dest.getVillage();
            if (unitOnDest != null) {
                if (unitOnDest.getControllingPlayer() == u.getControllingPlayer()) {
                    return MoveType.COMBINEUNITS;
                } else if (Unit.unitLevel(unitOnDest.getUnitType()) >= Unit.unitLevel(u.getUnitType())) {
                    return MoveType.INVALIDMOVE;
                } else if (Unit.unitLevel(unitOnDest.getUnitType()) < Unit.unitLevel(u.getUnitType())) {
                    return MoveType.FREEMOVE;
                }
                else {
                    /* INCOMPLETE */
                    return null;
                }
            }
            else {
                /* INCOMPLETE */
                return null;
            }
        } else {
            return MoveType.INVALIDMOVE;
        }
    }

    private void gatherWood(Unit u) {
        u.getTile().setTerrainType(TerrainType.MEADOW);
        u.setImmobileUntilRound(gameState.getRoundCount() + 1);
        u.setCurrentAction(ActionType.CHOPPINGTREE);
        u.getVillage().transactWood(1);
    }

    private void clearTombstone(Unit u) {
        u.getTile().setStructure(StructureType.TOMBSTONE);
        u.setImmobileUntilRound(gameState.getRoundCount() + 1);
        u.setCurrentAction(ActionType.CLEARINGTOMBSTONE);
    }

    private void trampleMeadow(Unit u) {
        Tile t = u.getTile(); 
        // Only Soldier and Knight trample meadows
        if (Unit.unitLevel(u.getUnitType()) >= 3 && t.getTerrainType() == TerrainType.MEADOW && t.getStructure() != StructureType.ROAD){
            u.getTile().setTerrainType(TerrainType.GRASS);
        }
    }

    private void phaseTombstone(Player p, Map m) {
        m.replaceTombstonesWithTrees(p);
    }

    private void phaseBuild(Player p) {
        List<Unit> units = p.getUnits();
        ActionType currentAction;
        for (Unit u : units) {
            currentAction = u.getCurrentAction();
            if (currentAction == ActionType.STARTCULTIVATING) {
                u.setCurrentAction(ActionType.FINISHCULTIVATING);
            } else if (currentAction == ActionType.FINISHCULTIVATING) {
                u.setCurrentAction(ActionType.READYFORORDERS);
                u.getTile().setTerrainType(TerrainType.MEADOW);
            } else {
             // The road structure was already placed as part of the build road operation
                u.setCurrentAction(ActionType.READYFORORDERS);
            }
        }
    }

    private void phaseIncome(Player p) {
        List<Village> villages = p.getVillages();
        for (Village v : villages) {
            v.transactGold(v.getTotalIncome());
        }
    }

    private void phasePayment(Player p) {
        List<Village> villages = p.getVillages();
        for (Village v : villages) {
            int totalUpkeep = v.getTotalUpkeep();
            if (v.getGold() < totalUpkeep) {
                v.killUnits();
            } else {
                v.transactGold(-1 * totalUpkeep);
            }
        }
    }

    public void moveUnit(Unit u, Tile dest) {
        MoveType moveType = getMoveType(u, dest);
        
        if (moveType == MoveType.INVALIDMOVE) {
            // Do nothing;
        } else if (moveType == MoveType.COMBINEUNITS) {
            combineUnits(dest.getUnit(), u);
        } else {
         // If there is an enemy unit, we kill it because we checked whether it was defeatable in getMoveType
            if (dest.getControllingPlayer() != u.getControllingPlayer() && dest.getUnit() != null) {
                dest.getUnit().kill();
            }
            
            // Move the unit
            Tile origin = u.getTile();
            origin.setUnit(null);
            dest.setUnit(u);
            u.setTile(dest);
            
            // Non-combat type actions
            if (moveType == MoveType.TRAMPLEMEADOW) {
                trampleMeadow(u);
            } else if (moveType == MoveType.CLEARTOMB) {
                clearTombstone(u);
            } else if (moveType == MoveType.GATHERWOOD) {
                gatherWood(u);
            }
            
            // Exiting the territory type actions
            if (dest.getControllingPlayer() == null) {
                combineRegions(u);
                u.setImmobileUntilRound(gameState.getRoundCount() + 1);
                u.setCurrentAction(ActionType.MOVED);
            } else if (dest.getControllingPlayer() != u.getControllingPlayer()) {
                takeoverTile(dest);
                u.setImmobileUntilRound(gameState.getRoundCount() + 1);
                u.setCurrentAction(ActionType.MOVED);
            }
        }
    }

    private void combineUnits(Unit dest, Unit moved) {
        /* TODO Implement */
        // This operation is a long series of if switches. Please see pseudocode.
    }

    private void combineRegions(Unit u) {
        /* TODO Implement */
        // This operation is two nested loops followed by two nested ifs. Please see the attached pseudocode.
        u.setCurrentAction(null);
    }

    private void splitRegions(Unit u) {
        Region region;
        Village village;
        Tile tile= u.getTile();
        List<Tile> neighbours = tile.getNeighbours();
        // Check if the tiles around the unit belong to a region that has been split.
        boolean replace = true;
        if (replace) {
            // Determine the set of connected tiles in each of the new regions
            for (;; /* each new set of tiles */) {
                if (replace /* set of tiles is greater than or equal to 3*/) {
                    // Create a new region with the set of connected tiles.
                    region = new Region(null, null);
                    region.createVillage();
                    village = region.getVillage();
                    // Iterate through every tile, set the village of each unit found to the new village.
                    for (Tile t : region.getTiles()) {
                        if (t.getUnit() != null) {
                            t.getUnit().setVillage(village);
                        }
                    }
                } else /* set of tiles is fewer than 3*/ {
                    // Remove all the tiles in the set from the region.
                    // If the tile contains a unit, kill the unit.
                }
            }
        }
    }
}
