package ca.mcgill.cs.comp361.nwo.mwgs.model;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Set;



/**
 * GameEngine class definition.
 * Generated by the TouchCORE code generator.
 */
public class GameEngine {
    
    private Game gameState;
    
    public void buildRoad(Unit u) {
        Tile tile;
        tile = u.getTile();
        if (u.getUnitType() == UnitType.PEASANT && tile.getStructure() != StructureType.ROAD) {
            u.setCurrentAction(ActionType.BUILDINGROAD);
            u.setImmobileUntilRound(gameState.getRoundCount() + 1);
            tile.setStructure(StructureType.ROAD);
        }
    }

    public void takeoverTile(Tile dest) {
        Unit unit = dest.getUnit();
        Region destRegion = dest.getRegion();
        Village destVillage = dest.getVillage();
        Village unitsVillage = unit.getVillage();
        
        if (destVillage != null) {
            unitsVillage.transactGold(destVillage.getGold());
            unitsVillage.transactWood(destVillage.getWood());
            dest.setVillage(null);
        }
        
        destRegion.removeTile(dest);
        unitsVillage.getRegion().addTile(dest);
        reconcileRegions(destRegion);
        checkWinConditions();
    }

    private void checkWinConditions() {
        List<Player> players = new ArrayList<Player>(gameState.getPlayers());
        for (Player p : players) {
            if (p.getVillages().size() <= 0) {
                players.remove(p);
            }
        }
        if (players.size() <= 1) {
            gameState.setHasWon(true);
            players.get(0).incrementWinCount();
            for (Player p : gameState.getPlayers()) {
                if (!p.equals(players.get(0))) p.incrementLossCount();
            }
        }
    }

    public void newGame(List<Player> players, String mapChosen) {
        /* TODO Correct SetUpMap */
        Map map = Map.setUpMap(players, mapChosen);
        Game game= new Game(players, map);
        Player.setUpPlayers(players);
        setGameState(game);
    }

    public void beginTurn(Game g, Player p) {
        Map map = g.getMap();
        phaseBuild(p);
        phaseTombstone(p, map);
        phaseIncome(p);
        phasePayment(p);
    }

    public void upgradeUnit(Unit u, UnitType newLevel) {
        Village v = u.getVillage();
        int cost = Unit.unitLevel(newLevel) - Unit.unitLevel(u.getUnitType());
        if (v.getGold() >= cost) {
            u.setUnitType(newLevel);
            v.transactGold(-1 * cost);
        }
    }

    public void upgradeVillage(Village v, VillageType newLevel) {
        int cost = Village.villageCost(newLevel) - Village.villageCost(v.getVillageType());
        if (v.getWood() >= cost) {
            v.setVillageType(newLevel);
            v.transactWood(-1 * cost);
        }
    }

    public void buildTower(Tile t) {
        /* TODO: No message view defined */
    }

    public Game getGameState() {
        return gameState;
    }

    public void setGameState(Game gameState) {
        this.gameState = gameState;
    }

    private MoveType getMoveType(Unit u, Tile dest) {
        /* TODO Implement */
        Tile origin = u.getTile();;
        List<Tile> adjacent = origin.getNeighbours();
        // Please refer to the attached pseudocode;
        // This sequence diagram does not check every case we intend to check;
        if (adjacent.contains(dest)) {
            TerrainType landOnDest = dest.getTerrainType();
            StructureType structureOnDest = dest.getStructure();
            Unit unitOnDest = dest.getUnit();
            Village villageOnDest = dest.getVillage();
            if (unitOnDest != null) {
                if (unitOnDest.getControllingPlayer() == u.getControllingPlayer()) {
                    return MoveType.COMBINEUNITS;
                } else if (Unit.unitLevel(unitOnDest.getUnitType()) >= Unit.unitLevel(u.getUnitType())) {
                    return MoveType.INVALIDMOVE;
                } else if (Unit.unitLevel(unitOnDest.getUnitType()) < Unit.unitLevel(u.getUnitType())) {
                    return MoveType.FREEMOVE;
                }
                else {
                    /* INCOMPLETE */
                    return null;
                }
            }
            else {
                /* INCOMPLETE */
                return null;
            }
        } else {
            return MoveType.INVALIDMOVE;
        }
    }

    private void gatherWood(Unit u) {
        u.getTile().setTerrainType(TerrainType.MEADOW);
        u.setImmobileUntilRound(gameState.getRoundCount() + 1);
        u.setCurrentAction(ActionType.CHOPPINGTREE);
        u.getVillage().transactWood(1);
    }

    private void clearTombstone(Unit u) {
        u.getTile().setStructure(StructureType.TOMBSTONE);
        u.setImmobileUntilRound(gameState.getRoundCount() + 1);
        u.setCurrentAction(ActionType.CLEARINGTOMBSTONE);
    }

    private void trampleMeadow(Unit u) {
        Tile t = u.getTile(); 
        // Only Soldier and Knight trample meadows
        if (Unit.unitLevel(u.getUnitType()) >= 3 && t.getTerrainType() == TerrainType.MEADOW && t.getStructure() != StructureType.ROAD){
            u.getTile().setTerrainType(TerrainType.GRASS);
        }
    }

    private void phaseTombstone(Player p, Map m) {
        m.replaceTombstonesWithTrees(p);
    }

    private void phaseBuild(Player p) {
        List<Unit> units = p.getUnits();
        ActionType currentAction;
        for (Unit u : units) {
            currentAction = u.getCurrentAction();
            if (currentAction == ActionType.STARTCULTIVATING) {
                u.setCurrentAction(ActionType.FINISHCULTIVATING);
            } else if (currentAction == ActionType.FINISHCULTIVATING) {
                u.setCurrentAction(ActionType.READYFORORDERS);
                u.getTile().setTerrainType(TerrainType.MEADOW);
            } else {
             // The road structure was already placed as part of the build road operation
                u.setCurrentAction(ActionType.READYFORORDERS);
            }
        }
    }

    private void phaseIncome(Player p) {
        List<Village> villages = p.getVillages();
        for (Village v : villages) {
            v.transactGold(v.getTotalIncome());
        }
    }

    private void phasePayment(Player p) {
        List<Village> villages = p.getVillages();
        for (Village v : villages) {
            int totalUpkeep = v.getTotalUpkeep();
            if (v.getGold() < totalUpkeep) {
                v.killUnits();
            } else {
                v.transactGold(-1 * totalUpkeep);
            }
        }
    }

    public void moveUnit(Unit u, Tile dest) {
        MoveType moveType = getMoveType(u, dest);
        
        if (moveType == MoveType.INVALIDMOVE) {
            // Do nothing;
        } else if (moveType == MoveType.COMBINEUNITS) {
            combineUnits(dest.getUnit(), u);
        } else {
         // If there is an enemy unit, we kill it because we checked whether it was defeatable in getMoveType
            if (dest.getControllingPlayer() != u.getControllingPlayer() && dest.getUnit() != null) {
                dest.getUnit().kill();
            }
            
            // Move the unit
            Tile origin = u.getTile();
            origin.setUnit(null);
            dest.setUnit(u);
            u.setTile(dest);
            
            // Non-combat type actions
            if (moveType == MoveType.TRAMPLEMEADOW) {
                trampleMeadow(u);
            } else if (moveType == MoveType.CLEARTOMB) {
                clearTombstone(u);
            } else if (moveType == MoveType.GATHERWOOD) {
                gatherWood(u);
            }
            
            // Exiting the territory type actions
            if (dest.getControllingPlayer() == null) {
                combineRegions(u);
                u.setImmobileUntilRound(gameState.getRoundCount() + 1);
                u.setCurrentAction(ActionType.MOVED);
            } else if (dest.getControllingPlayer() != u.getControllingPlayer()) {
                takeoverTile(dest);
                u.setImmobileUntilRound(gameState.getRoundCount() + 1);
                u.setCurrentAction(ActionType.MOVED);
            }
        }
    }

    private void combineUnits(Unit dest, Unit moved) {
        /* TODO Implement */
        // This operation is a long series of if switches. Please see pseudocode.
    }

    private void combineRegions(Unit u) {
        /* TODO Implement */
        // This operation is two nested loops followed by two nested ifs. Please see the attached pseudocode.
        u.setCurrentAction(null);
    }

    /* DEPRECATED, DO NOT USE, USE reconcileRegions(Region r) INSTEAD */
//    private void splitRegions(Unit u) {
//        Region region;
//        Village village;
//        Tile tile= u.getTile();
//        List<Tile> neighbours = tile.getNeighbours();
//        // Check if the tiles around the unit belong to a region that has been split.
//        boolean replace = true;
//        if (replace) {
//            // Determine the set of connected tiles in each of the new regions
//            for (;; /* each new set of tiles */) {
//                if (replace /* set of tiles is greater than or equal to 3*/) {
//                    // Create a new region with the set of connected tiles.
//                    region = new Region(null, null);
//                    region.createVillage();
//                    village = region.getVillage();
//                    // Iterate through every tile, set the village of each unit found to the new village.
//                    for (Tile t : region.getTiles()) {
//                        if (t.getUnit() != null) {
//                            t.getUnit().setVillage(village);
//                        }
//                    }
//                } else /* set of tiles is fewer than 3*/ {
//                    // Remove all the tiles in the set from the region.
//                    // If the tile contains a unit, kill the unit.
//                }
//            }
//        }
//    }
    
    private void reconcileRegions(Region r) {
        Player controllingPlayer = r.getControllingPlayer();
        Village originalVillage = r.getVillage();
        List<Tile> unreached = new ArrayList<Tile>(r.getTiles());
        List<List<Tile>> newRegionList = new ArrayList<List<Tile>>();
        
        while (unreached.size() > 0) {
            // Take the first tile (an arbitrary tile)
            Tile begin = unreached.get(0);
            List<Tile> temp = new ArrayList<Tile>();
            // Move the tile from the unreached list to the the temp list
            temp.add(begin);
            unreached.remove(begin);
            // Determine the set of connected tiles
            Set<Tile> connected = reachableTilesInSameRegion(begin, r, new HashSet<Tile>());
            // Add all the connected tiles to the temp list and remove them from the unreached list
            temp.addAll(connected);
            unreached.removeAll(connected);
            // Add the temp list to the new region list
            newRegionList.add(temp);
        }
        
        for (List<Tile> l : newRegionList) {
            /* This is a set of tiles with insufficient tiles to form a region */ 
            if (l.size() < 3) {
                for (Tile t : l) {
                    if (t.getVillage() != null) {
                        t.getVillage().kill();
                    }
                    if (t.getUnit() != null) {
                        t.getUnit().kill();
                        t.setRegion(null);
                    }
                }
            }
            /* This is the 'original' region */
            else if (originalVillage != null && l.contains(originalVillage.getTile())) {
                List<Tile> notInRegion = new ArrayList<Tile>(r.getTiles());
                notInRegion.removeAll(l);
                for (Tile t : notInRegion) {
                    r.removeTile(t);
                }
                if (r.getVillage() == null) r.createVillage();
            }
            /* This is newly created region with > 3 non-village tiles, with no contolling village */
            else {
                Region newRegion = new Region(l, controllingPlayer);
                newRegion.createVillage();
                for (Tile t : l) {
                    t.setRegion(newRegion);
                    if (t.getUnit() != null) t.getUnit().setVillage(newRegion.getVillage());
                }
            }
        }
    }
    
    /**
     * Recursive function to traverse the map and find all reachable tiles from the same former region
     * @param from The tile to search from
     * @param r The "original" region the tiles were a part of
     * @param reached The set of tiles that has been reached
     * @return
     */
    private Set<Tile> reachableTilesInSameRegion(Tile from, Region r, Set<Tile> reached) {
        
        for (Tile t : from.getNeighbours()) {
            if (t.getRegion() == r && !reached.contains(t)) {
                reached.add(t);
                reached.addAll(reachableTilesInSameRegion(t, r, reached));
            }
        }
        return new HashSet<Tile>(reached);
    }
}
